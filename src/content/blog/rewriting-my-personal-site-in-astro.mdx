---
title: Rewriting My Personal Site in Astro
description: Why I decided to rewrite my personal site in Astro and how it went.
pubDate: 12-22-2024
heroImage:
  [
    ../../assets/images/blog/rewriting-my-personal-site-in-astro/hero.jpg,
    "A person working on a laptop with a website or blog featuring a modern, clean design visible on the screen.",
  ]
heroImageCredit: [ChatGPT, ""]
isDraft: true
---

I've been wanting to do a rewrite of my personal site for a while now. This is a summary of how I ended up replacing NextJS with Astro and my journey in making the shift. I'll talk about some of my favorite features in Astro, as well as a few aspects of the framework I found to be less than great.

(yes, you are looking at the new version which likely looks identical to the old version and that's by design. I wanted to re-create the existing site in Astro. To ensure it was an apples to apples update.)

## Deciding on sticking with NextJS or making a Switch

While the previous version of this site, written in NextJS, was perfectly functional, it was just starting to feel dated at the code level.

For example. I was using an older version of NextJS (v12), with the [old page router model](https://nextjs.org/docs/pages). I considered sticking with NextJS and updating it to use the new [app router](https://nextjs.org/docs/app) model. But soon after digging into what that would require, it just felt like overkill for a mostly static site with a blog.

**TODO: add callout box: "NextJS just felt like overkill for a mostly static site with a blog."**

Instead, I decided to use the opportunity to try out one of the newer frameworks. These were some of the key features I was looking for:

- Optimized for mostly static, content-rich sites.
- Supports [mdx](https://mdxjs.com/) content out of the box. (All my current blog posts are writting in mdx.)
- Allows for optionally adding advanced UI functionality, eg via React components or something similar.

I considered a number of options, including [Svelte](https://svelte.dev/), [Qwik](https://qwik.dev/), [Htmx](https://htmx.org/), but in the end, I decided to go with [Astro](https://astro.build/), which checks all of the above boxes and more.

Here are a few of the main reasons why, as well as some challenges I encountered.

## MDX and other "batteries" included

With my old version of the app, quite a bit was required to get MDX working, including installing and configuring [next-mdx-remote](https://www.npmjs.com/package/next-mdx-remote), and multiple other packages such as [gray-matter](https://www.npmjs.com/package/gray-matter), to allow for reading in mdx files and frontmatter, handling code syntax highlighting and more. If I had stuck with the new version of Next, there would still be [quite a bit of config](https://nextjs.org/docs/pages/building-your-application/configuring/mdx) required.

With Astro, just run `npx astro add mdx`, follow the prompts, and you're good to go. This is thanks to their numerous [automatic integration setups](https://docs.astro.build/en/guides/integrations-guide/) for their official integrations, which includes mdx.

So much of what I had previously needed to set up manually just worked out of the box, including handling of [frontmatter](https://wiki.dendron.so/notes/ffec2853-c0e0-4165-a368-339db12c8e4b/), code syntax highlighting, and more.

(As an aside, I can't understand why NextJS doesn't add these types of wizard-like features, but that's a topic for another day.)

## Astro components are the markdown version of React components + server-side code

If you compare an HTML snippet to the equivalent markdown you get an good idea of the difference between how much less code you need to write with Astro.

Similar to how it is to learn markdown if you already know HTML, you can basically just start writing it immediately. No rampup time needed. Sure, if you want to do something a little more advanced, you may have to do some quick research, but in many cases I found I could just sort of grok how, say, a concept from React translated to Astro.

This is the basic structure of an [Astro component](https://docs.astro.build/en/basics/astro-components/).

```javascript
----
 // optional component scripts
---

<div>JSX with a few astro-specific tweaks go here</div>

<scripts>
// optional client-side scripts
</scripts>

<style>
  /* optional local styles */
</style>
```

(Btw, this is not unique to Astro. For example, Svelte and Qwik... )

Note that everything except for the jsx is optional. Here is a comparison of one such minimal React component vs the Astro equivalent.

```jsx
interface Props {
  children: React.ReactElement;
}

export function CalloutBox({ children }: Props) {
  return (
    <div
      className={
        "bg-slate-100 md:rounded-md pt-3 md:pt-2 p-2 prose-headings:mt-2"
      }
    >
      {children}
    </div>
  );
}
```

And the equivalent Astro code:

```jsx
<div class={"bg-slate-100 md:rounded-md pt-3 md:pt-2 p-2 prose-headings:mt-2"}>
  <slot />
</div>
```

In this case, we went from 15 to 3 lines of code. :tada:

Note how it's not even necessary to name your component in the file as it's just a default export and you can name it whatever you want when importing. (See below for more on, while I like how this reduces the amount of you code you need to write, it also can create some headaches.)

## I assumed I'd still need React, but apparently not

As I mentioned earlier, one of my requirements for the selected framework was to allow for continuing to use tools I already know, such as React. I just assumed I'd need it for more advanced features.

Well, as it turned out, I was happily surprised to not have to add React, at least so far.

Time and again, I would start porting over some feature, and it would turn out no React was needed.

(CALLOUT) The general pattern, I found, is that you can usually just replace some react-specific package with a more generic or framework-agnostic equivalent.

For example, I was using [react icons](https://react-icons.github.io/react-icons/) for display of icons. In that, I was able to quite easily replace it with [iconify](https://iconify.design/).

(Btw, this is not unique to Astro. For example, Svelte and Qwik... )

And the best part is that if I should encounter a feature for which I can't find a good generic version, well, adding React is always an option.

## Not all roses

While I am definitely overall happy with making the switch, there were definitely some areas of frustration.

- Only one component per file
- Great schema modeling using Zod, but it doesn't carry over into the mdx frontmatter and leveraging the types in your code is not immeditely clear.
- Some quirk with setting up my IDE as well the need to frequently run the sync command.

I really like the content collections model, in particular being able to type it using Zod. I'm not a huge fan of Zod, as I do not find the API to be intuititve (eg the meaning of `.string()` vs `.string().optional()`) But I've used it before so no big deal.

However, since the typed content is likely to be entered via mdx frontmatter, it would really be great if those values also could be validated. For example, I mistakenly put `draft` rather than `isDraft` and there was no error.  
There is an open request in Astro to add this. Please upvote it if you agree these should be typed.

Figuring out how to integtate this with mdx files was confusing. For example, I can include a path to a hero image that will be optimized but only if I use it outside the mdx file, ie in the wrapping Astro component. Here is a code sample to explain:

At the same time, if I want to include an optimized image within the mdx, then each one has to be imported individually.

The image processing feature is great but it would be even better if I could just place images I wanted in a folder and import the optimized images from a collection rather than have to handle each one individually.

A few things about Astro were confusing. For example, I had to in many cases run the `sync` command to generate needed types.

I also would prefer to in some cases be able to have more than one component per file, eg in the case of teh Welcome hero. At the same time, I can also see the reasoning and potential benefits of enforcing a single compoent per file (I think Svelte started out this way but later caved and now allows multiple components in a file.)

Astro components are default exported which on one hand is nice, but on the other created some challenges with my IDE to enable auto import.

Ran into some issues with the prettier formatting.

Astro comes with Zod included and is used for schema typing. This was great but it wasn't clear how to make use of those types elsehwere in the app.

## Keeping it open source

I'll write more about this in another post, but I also made the decision to have the repo be public from the start. There really wasn't a reason for something like this to be private. And by having it be public, I think that also encourages a code base that overall is tidier, better commit hygiene and more.

Feel free to take a look at the source and let me know your thoughts either via Threads or Bluesky.

**TODO: enable share links to Bluesky and Threads**

# NOTES

This means a lot less code was needed to ship the same functionality (look into comparing total lines of code.)

Astro is also just more minimal in several important ways and has been optimized for making static content load super fast.
